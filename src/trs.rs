use crate::git::RepoUrl;
use crate::utils;
use crate::utils::CommitUser;
use crate::Opt;

use std::fs;
use std::io::{BufWriter, Write};
use std::path::{Path, PathBuf};

use anyhow::{anyhow, Context, Result};
use chrono::Utc;
use path_clean::PathClean;
use serde::{Deserialize, Serialize};
use serde_json;
use url::Url;

#[derive(Serialize, Deserialize, Debug)]
#[serde(rename_all = "camelCase")]
struct ServiceInfo {
    id: String,
    name: String,
    r#type: ServiceType,
    description: String,
    organization: ServiceOrganization,
    contact_url: Url,
    documentation_url: Url,
    created_at: String,
    updated_at: String,
    environment: String,
    version: String,
}

#[derive(Serialize, Deserialize, Debug)]
struct ServiceType {
    group: String,
    artifact: String,
    version: String,
}

#[derive(Serialize, Deserialize, Debug)]
struct ServiceOrganization {
    name: String,
    url: Url,
}

impl ServiceInfo {
    fn new(opt: &Opt, repo_url: &RepoUrl, commit_user: &CommitUser) -> Result<ServiceInfo> {
        let now = Utc::now();
        let repo_owner = utils::repo_owner(repo_url)?;
        let repo_name = utils::repo_name(repo_url)?;
        let service_info = ServiceInfo {
            id: format!("io.github.{}", &repo_owner),
            name: format!("{}/{}", &repo_owner, &repo_name),
            r#type: ServiceType {
                group: format!("io.github.{}", &repo_owner),
                artifact: "TRS".to_string(),
                version: "gh-trs-1.0.0".to_string(),
            },
            description: "Generated by gh-trs.".to_string(),
            organization: ServiceOrganization {
                name: repo_owner.clone(),
                url: Url::parse(&format!("https://github.com/{}", &repo_owner))
                    .context("Failed to parse the organization URL in service-info response.")?,
            },
            contact_url: Url::parse(&format!("mailto:{}", commit_user.email))
                .context("Failed to parse the contact URL in service-info response.")?,
            documentation_url: Url::parse(&format!(
                "https://{}.github.io/{}",
                &repo_owner, &repo_name
            ))
            .context("Failed to parse the documentation URL in service-info response.")?,
            created_at: format!("{}", now.format("%Y-%m-%dT%H:%M:%SZ")),
            updated_at: format!("{}", now.format("%Y-%m-%dT%H:%M:%SZ")),
            environment: opt.environment.to_string(),
            version: format!("{}", Utc::today().format("%Y%m%d")),
        };
        Ok(service_info)
    }
}

fn dump_service_info(
    opt: &Opt,
    repo_url: &RepoUrl,
    commit_user: &CommitUser,
    dest_dir: &Path,
) -> Result<()> {
    let service_info = ServiceInfo::new(opt, repo_url, commit_user)?;
    let service_info_dir_path = Path::new(dest_dir)
        .join(&opt.dest)
        .join("service-info")
        .clean();
    fs::create_dir_all(service_info_dir_path.as_path()).with_context(|| {
        format!(
            "Failed to create dir: {:?}",
            service_info_dir_path.as_path()
        )
    })?;
    let service_info_file_path = Path::new(dest_dir)
        .join(&opt.dest)
        .join("service-info/index.json")
        .clean();
    let mut f = BufWriter::new(
        fs::File::create(service_info_file_path.as_path()).with_context(|| {
            format!(
                "Failed to create file: {:?}",
                service_info_file_path.as_path()
            )
        })?,
    );
    f.write_all(
        serde_json::to_string(&service_info)
            .context("Failed to serialize the service-info response.")?
            .as_bytes(),
    )
    .with_context(|| format!("Failed to write file: {:?}", service_info_file_path))?;
    Ok(())
}

pub fn generate_trs_responses(
    opt: &Opt,
    repo_url: &RepoUrl,
    commit_user: &CommitUser,
    dest_dir: &Path,
) -> Result<()> {
    dump_service_info(opt, repo_url, commit_user, dest_dir)?;
    Ok(())
}

pub fn trs_url(repo_url: &RepoUrl, dest: &PathBuf) -> Result<String> {
    let path = Path::new(&format!("/{}", &utils::repo_name(&repo_url)?))
        .join(dest)
        .clean();
    Ok(format!(
        "https://{}.github.io{:?}",
        utils::repo_owner(&repo_url)?,
        path.to_str()
            .ok_or(anyhow!("Failed to change pathBuf to str."))?
    ))
}

#[cfg(test)]
mod tests {
    use super::*;

    mod new_service_info {
        use super::*;
        use crate::utils;
        use crate::{Opt, Scheme};
        use std::env;
        use structopt::StructOpt;

        #[test]
        fn ok() {
            let opt = Opt::from_iter(vec![""].iter());
            let cwd = env::current_dir().unwrap();
            let repo_url = utils::resolve_repository_url(
                "git",
                &env::current_dir().unwrap(),
                "origin",
                &Some("https://github.com/suecharo/gh-trs.git".to_string()),
                &Scheme::Https,
            )
            .unwrap();
            let commit_user =
                utils::resolve_commit_user(&opt.git, &cwd, &opt.user_name, &opt.user_email)
                    .unwrap();

            // println
        }
    }
}
