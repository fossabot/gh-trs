use crate::utils;
use crate::utils::CommitUser;
use crate::Opt;

use std::fs;
use std::io::{BufWriter, Write};
use std::path::Path;

use chrono::Utc;
use path_clean::PathClean;
use serde::{Deserialize, Serialize};
use serde_json;
use url::Url;

#[derive(Serialize, Deserialize, Debug)]
struct ServiceInfo {
    id: String,
    name: String,
    r#type: ServiceType,
    description: String,
    organization: ServiceOrganization,
    contact_url: Url,
    documentation_url: Url,
    created_at: String,
    updated_at: String,
    environment: String,
    version: String,
}

#[derive(Serialize, Deserialize, Debug)]
struct ServiceType {
    group: String,
    artifact: String,
    version: String,
}

#[derive(Serialize, Deserialize, Debug)]
struct ServiceOrganization {
    name: String,
    url: Url,
}

impl ServiceInfo {
    fn new(opt: &Opt, repo_url: &Url, commit_user: &CommitUser) -> ServiceInfo {
        let now = Utc::now();
        ServiceInfo {
            id: format!("io.github.{}", utils::repo_owner(repo_url)),
            name: format!(
                "{}/{}",
                utils::repo_owner(repo_url),
                utils::repo_name(repo_url)
            ),
            r#type: ServiceType {
                group: format!("io.github.{}", utils::repo_owner(repo_url)),
                artifact: "TRS".to_string(),
                version: "gh-trs-1.0.0".to_string(),
            },
            description: "Generated by gh-trs.".to_string(),
            organization: ServiceOrganization {
                name: utils::repo_owner(repo_url),
                url: Url::parse(&format!(
                    "https://github.com/{}",
                    utils::repo_owner(repo_url)
                ))
                .unwrap(),
            },
            contact_url: Url::parse(&format!("mailto:{}", commit_user.email)).unwrap(),
            documentation_url: Url::parse(&format!(
                "https://{}.github.io/{}",
                utils::repo_owner(repo_url),
                utils::repo_name(repo_url)
            ))
            .unwrap(),
            created_at: format!("{}", now.format("%Y-%m-%dT%H:%M:%SZ")),
            updated_at: format!("{}", now.format("%Y-%m-%dT%H:%M:%SZ")),
            environment: opt.environment.to_string(),
            version: format!("{}", Utc::today().format("%Y%m%d")),
        }
    }
}

pub fn generate_rest_api(opt: &Opt, repo_url: &Url, commit_user: &CommitUser, dest_dir: &Path) {
    let service_info = ServiceInfo::new(opt, repo_url, commit_user);
    let service_info_dir_path = Path::new(dest_dir)
        .join(&opt.dest)
        .join("service-info")
        .clean();
    fs::create_dir_all(service_info_dir_path).unwrap();
    let service_info_file_path = Path::new(dest_dir)
        .join(&opt.dest)
        .join("service-info/index.json")
        .clean();
    let mut f = BufWriter::new(fs::File::create(service_info_file_path).unwrap());
    f.write_all(serde_json::to_string(&service_info).unwrap().as_bytes())
        .unwrap();
}
