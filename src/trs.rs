use crate::git::RepoUrl;
use crate::utils;
use crate::utils::{Attachment, CommitUser, Config, Testing, Tool};
use crate::Opt;
use anyhow::{anyhow, Context, Result};
use chrono::Utc;
use path_clean::PathClean;
use serde::{Deserialize, Serialize};
use serde_json;
use std::fs;
use std::io::{BufWriter, Write};
use std::path::Path;
use url::Url;

#[derive(Serialize, Deserialize, Debug)]
#[serde(rename_all = "camelCase")]
struct ServiceInfo {
    id: String,
    name: String,
    r#type: ServiceType,
    description: String,
    organization: ServiceOrganization,
    contact_url: Url,
    documentation_url: Url,
    created_at: String,
    updated_at: String,
    environment: String,
    version: String,
}

#[derive(Serialize, Deserialize, Debug)]
struct ServiceType {
    group: String,
    artifact: String,
    version: String,
}

#[derive(Serialize, Deserialize, Debug)]
struct ServiceOrganization {
    name: String,
    url: Url,
}

impl ServiceInfo {
    /// Generate the service info.
    ///
    /// * `opt` - Argument Parameters defined at `main.rs`
    /// * `repo_url` - The repository URL.
    /// * `commit_user` - The commit user.
    fn new(opt: &Opt, repo_url: &RepoUrl, commit_user: &CommitUser) -> Result<Self> {
        let now = Utc::now();
        let repo_owner = utils::repo_owner(&repo_url)?;
        let repo_name = utils::repo_name(&repo_url)?;
        Ok(Self {
            id: format!("io.github.{}", &repo_owner),
            name: format!("{}/{}", &repo_owner, &repo_name),
            r#type: ServiceType {
                group: format!("io.github.{}", &repo_owner),
                artifact: "TRS".to_string(),
                version: "gh-trs-1.0.0".to_string(),
            },
            description: "Generated by gh-trs.".to_string(),
            organization: ServiceOrganization {
                name: repo_owner.clone(),
                url: Url::parse(&format!("https://github.com/{}", &repo_owner))?,
            },
            contact_url: Url::parse(&format!("mailto:{}", &commit_user.email))?,
            documentation_url: Url::parse(&format!(
                "https://{}.github.io/{}",
                &repo_owner, &repo_name
            ))?,
            created_at: format!("{}", now.format("%Y-%m-%dT%H:%M:%SZ")),
            updated_at: format!("{}", now.format("%Y-%m-%dT%H:%M:%SZ")),
            environment: opt.environment.clone(),
            version: format!("{}", Utc::today().format("%Y%m%d")),
        })
    }
}

/// Generate TRS response.
///
/// * `opt`: Argument Parameters defined at `main.rs`.
/// * `repo_url`: Repository URL.
/// * `commit_user`: Commit user.
/// * `wd`: Working directory.
/// * `config`: gh-trs configuration.
pub fn generate_trs_responses(
    opt: &Opt,
    repo_url: &RepoUrl,
    commit_user: &CommitUser,
    wd: impl AsRef<Path>,
    config: &Config,
) -> Result<()> {
    dump_service_info(&opt, &repo_url, &commit_user, &wd)?;
    dump_tools(&opt, &wd, &config)?;
    Ok(())
}

/// Dump the service info.
///
/// * `opt`: Argument Parameters defined at `main.rs`.
/// * `repo_url`: Repository URL.
/// * `commit_user`: Commit user.
/// * `wd`: Working directory.
fn dump_service_info(
    opt: &Opt,
    repo_url: &RepoUrl,
    commit_user: &CommitUser,
    wd: impl AsRef<Path>,
) -> Result<()> {
    let service_info = ServiceInfo::new(&opt, &repo_url, &commit_user)?;
    let service_info_path = wd
        .as_ref()
        .join(&opt.dest)
        .join("service-info/index.json")
        .clean();
    dump_file(&service_info_path, &serde_json::to_string(&service_info)?)?;
    Ok(())
}

/// Dump the tools.
///
/// * `opt`: Argument Parameters defined at `main.rs`.
/// * `repo_url`: Repository URL.
/// * `commit_user`: Commit user.
/// * `wd`: Working directory.
/// * `config`: gh-trs configuration.
fn dump_tools(opt: &Opt, wd: impl AsRef<Path>, config: &Config) -> Result<()> {
    dump_tools_root(&opt, &wd, &config)?;
    dump_each_tool(&opt, &wd, &config)?;
    Ok(())
}

/// Dump the tools root.
///
/// * `opt`: Argument Parameters defined at `main.rs`.
/// * `wd`: Working directory.
/// * `config`: gh-trs configuration.
fn dump_tools_root(opt: &Opt, wd: impl AsRef<Path>, config: &Config) -> Result<()> {
    let tool_ids = config.extract_tool_ids()?;
    let tools_root_path = wd.as_ref().join(&opt.dest).join("tools/index.json").clean();
    dump_file(&tools_root_path, &serde_json::to_string(&tool_ids)?)?;
    Ok(())
}

#[derive(Debug, Deserialize, Serialize, Clone)]
pub struct TrsTool {
    id: String,
    url: Url,
    version: String,
    language_type: String,
    attachments: Option<Vec<Attachment>>,
    testing: Option<Testing>,
}

impl TrsTool {
    fn new(tool: &Tool) -> Result<Self> {
        Ok(Self {
            id: tool.id.clone(),
            url: tool.url.clone(),
            version: github_url_to_tool_version(&tool.url)?,
            language_type: tool.language_type.clone(),
            attachments: tool.attachments.clone(),
            testing: tool.testing.clone(),
        })
    }
}

/// Convert tool's GitHub raw-contents URL to TRS tool version.
/// Expected input: https://raw.githubusercontent.com/suecharo/gh-trs/0fb996810f153be9ad152565227a10e402950953/tests/resources/cwltool/fastqc.cwl
/// Output: suecharo_gh-trs_0fb996810f153be9ad152565227a10e402950953
fn github_url_to_tool_version(github_url: &Url) -> Result<String> {
    let path_segments = github_url
        .path_segments()
        .ok_or(anyhow!("Failed to parse path in parsed URL."))?
        .collect::<Vec<&str>>();
    Ok(format!(
        "{repo_owner}_{repo_name}_{commit_hash}",
        repo_owner = path_segments[0],
        repo_name = path_segments[1],
        commit_hash = path_segments[2]
    ))
}

/// Dump each tool.
///
/// * `opt`: Argument Parameters defined at `main.rs`.
/// * `wd`: Working directory.
/// * `config`: gh-trs configuration.
fn dump_each_tool(opt: &Opt, wd: impl AsRef<Path>, config: &Config) -> Result<()> {
    for tool in &config.tools {
        let trs_tool = TrsTool::new(&tool)?;
        let tool_path = wd
            .as_ref()
            .join(&opt.dest)
            .join(format!("tools/{}/index.json", &tool.id))
            .clean();
        dump_file(&tool_path, &serde_json::to_string(&trs_tool)?)?;
    }
    Ok(())
}

// Create dir -> Write file
fn dump_file(file_path: impl AsRef<Path>, file_content: impl AsRef<str>) -> Result<()> {
    let dir_path = file_path
        .as_ref()
        .parent()
        .ok_or(anyhow!("Failed to get the parent path."))?;
    fs::create_dir_all(&dir_path)
        .with_context(|| format!("Failed to create dir: {:?}", &dir_path))?;
    let mut f = BufWriter::new(
        fs::File::create(&file_path.as_ref())
            .with_context(|| format!("Failed to create file: {:?}", file_path.as_ref()))?,
    );
    f.write_all(file_content.as_ref().as_bytes())
        .with_context(|| format!("Failed to write file: {:?}", file_path.as_ref()))?;
    Ok(())
}

pub fn trs_url(repo_url: &RepoUrl, dest: impl AsRef<Path>) -> Result<String> {
    let path = Path::new(&format!("/{}", &utils::repo_name(&repo_url)?))
        .join(&dest)
        .clean();
    Ok(format!(
        "https://{}.github.io{}",
        utils::repo_owner(&repo_url)?,
        path.to_str()
            .ok_or(anyhow!("Failed to change pathBuf to str."))?
    ))
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::utils;
    use crate::{Opt, Scheme};
    use std::env;
    use structopt::StructOpt;
    use temp_dir::TempDir;

    mod new_service_info {
        use super::*;

        #[test]
        fn ok() {
            let opt = Opt::from_iter(&["gh-trs", "gh-trs.yml"]);
            let repo_url =
                RepoUrl::new("ssh://git@github.com/suecharo/gh-trs.git", &Scheme::Ssh).unwrap();
            let commit_user = CommitUser {
                name: "suecharo".to_string(),
                email: "foobar@example.com".to_string(),
            };
            let service_info = ServiceInfo::new(&opt, &repo_url, &commit_user).unwrap();
            assert_eq!(service_info.id, "io.github.suecharo");
            assert_eq!(service_info.name, "suecharo/gh-trs");
            assert_eq!(service_info.r#type.group, "io.github.suecharo");
            assert_eq!(service_info.r#type.artifact, "TRS");
            assert_eq!(service_info.r#type.version, "gh-trs-1.0.0");
            assert_eq!(service_info.description, "Generated by gh-trs.");
            assert_eq!(service_info.organization.name, "suecharo");
            assert_eq!(
                service_info.organization.url,
                Url::parse("https://github.com/suecharo").unwrap()
            );
            assert_eq!(
                service_info.contact_url,
                Url::parse("mailto:foobar@example.com").unwrap()
            );
            assert_eq!(
                service_info.documentation_url,
                Url::parse("https://suecharo.github.io/gh-trs").unwrap()
            );
            assert_eq!(service_info.environment, "prod");
        }
    }

    mod generate_trs_responses {
        use super::*;

        #[test]
        fn ok() {
            let opt = Opt::from_iter(&["gh-trs", "gh-trs.yml"]);
            let repo_url =
                RepoUrl::new("ssh://git@github.com/suecharo/gh-trs.git", &Scheme::Ssh).unwrap();
            let commit_user = CommitUser {
                name: "suecharo".to_string(),
                email: "foobar@example.com".to_string(),
            };
            let mut cwd = env::current_dir().unwrap();
            cwd.push("tests/gh-trs.test.yml");
            let test_file = cwd.canonicalize().unwrap();
            let config = utils::validate_and_convert_config(
                utils::load_config(test_file.to_str().ok_or("").unwrap()).unwrap(),
            )
            .unwrap();
            let temp_dir = TempDir::with_prefix("gh-trs").unwrap();
            generate_trs_responses(&opt, &repo_url, &commit_user, temp_dir.path(), &config)
                .unwrap();
        }
    }

    mod dump_service_info {
        use super::*;

        #[test]
        fn ok() {
            let opt = Opt::from_iter(&["gh-trs", "gh-trs.yml"]);
            let repo_url =
                RepoUrl::new("ssh://git@github.com/suecharo/gh-trs.git", &Scheme::Ssh).unwrap();
            let commit_user = CommitUser {
                name: "suecharo".to_string(),
                email: "foobar@example.com".to_string(),
            };
            let temp_dir = TempDir::with_prefix("gh-trs").unwrap();
            dump_service_info(&opt, &repo_url, &commit_user, temp_dir.path()).unwrap();
        }
    }

    mod dump_tools {
        use super::*;

        #[test]
        fn ok() {
            let opt = Opt::from_iter(&["gh-trs", "gh-trs.yml"]);
            let temp_dir = TempDir::with_prefix("gh-trs").unwrap();
            let config = Config::new().unwrap();
            dump_tools(&opt, temp_dir.path(), &config).unwrap();
        }
    }

    mod dump_file {
        use super::*;

        #[test]
        fn ok() {
            let temp_dir = TempDir::with_prefix("gh-trs").unwrap();
            let test_file_path = temp_dir.child("tests/test.txt");
            dump_file(&test_file_path, "foobar").unwrap();
            assert!(test_file_path.exists());
        }
    }

    mod trs_url {
        use super::*;

        #[test]
        fn ok() {
            let repo_url =
                RepoUrl::new("ssh://git@github.com/suecharo/gh-trs.git", &Scheme::Ssh).unwrap();
            let trs_url = trs_url(&repo_url, ".").unwrap();
            assert_eq!(trs_url, "https://suecharo.github.io/gh-trs");
        }
    }
}
