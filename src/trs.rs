use crate::config;

use anyhow::{anyhow, Result};
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use url::Url;
use uuid::Uuid;

/// https://raw.githubusercontent.com/ga4gh-discovery/ga4gh-service-info/v1.0.0/service-info.yaml#/paths/~1service-info
#[derive(Debug, PartialEq, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct ServiceInfo {
    pub id: String,
    pub name: String,
    pub r#type: ServiceType,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    pub organization: Organization,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub contact_url: Option<Url>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub documentation_url: Option<Url>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub created_at: Option<DateTime<Utc>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub updated_at: Option<DateTime<Utc>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub environment: Option<String>,
    pub version: String,
}

#[derive(Debug, PartialEq, Clone, Serialize, Deserialize)]
pub struct ServiceType {
    pub group: String,
    pub artifact: String,
    pub version: String,
}

impl Default for ServiceType {
    fn default() -> Self {
        Self {
            group: "gh-trs".to_string(),
            artifact: "gh-trs".to_string(),
            version: "2.0.1".to_string(),
        }
    }
}

#[derive(Debug, PartialEq, Clone, Serialize, Deserialize)]
pub struct Organization {
    pub name: String,
    pub url: Url,
}

impl ServiceInfo {
    fn new(config: &config::Config, owner: impl AsRef<str>, name: impl AsRef<str>) -> Result<Self> {
        let created_at = Utc::now();
        Ok(Self {
            id: format!("io.github.{}.{}", owner.as_ref(), name.as_ref()),
            name: format!("gh-trs {}/{}", owner.as_ref(), name.as_ref()),
            r#type: ServiceType::default(),
            description: Some(
                "The GA4GH TRS API generated by gh-trs (https://github.com/suecharo/gh-trs)"
                    .to_string(),
            ),
            organization: Organization {
                name: config.authors[0].github_account.clone(), // already validated
                url: Url::parse(&format!(
                    "https://github.com/{}",
                    config.authors[0].github_account // already validated
                ))?,
            },
            contact_url: None::<Url>,
            documentation_url: None::<Url>,
            created_at: Some(created_at),
            updated_at: Some(created_at.clone()),
            environment: None::<String>,
            version: created_at.format("%Y%m%d%H%M%S").to_string(),
        })
    }

    /// Basically, prev has priority in all fields.
    /// This is only for service-info, because there may be cases where to modify service-info by hand.
    pub fn new_or_update(
        prev: Option<Self>,
        config: &config::Config,
        owner: impl AsRef<str>,
        name: impl AsRef<str>,
    ) -> Result<Self> {
        let mut new = Self::new(config, owner, name)?;
        if let Some(prev) = prev {
            new.id = prev.id;
            new.name = prev.name;
            new.r#type = prev.r#type;
            new.description = prev.description;
            new.organization = prev.organization;
            new.contact_url = prev.contact_url;
            new.documentation_url = prev.documentation_url;
            new.created_at = prev.created_at;
            new.environment = prev.environment;
        }
        Ok(new)
    }
}

// --- GA4GH TRS API v2.0.1 type definition ---
// https://editor.swagger.io/?url=https://raw.githubusercontent.com/ga4gh/tool-registry-schemas/develop/openapi/openapi.yaml

#[derive(Debug, PartialEq, Clone, Serialize, Deserialize)]
pub struct Checksum {
    pub checksum: String,
    pub r#type: String,
}

#[derive(Debug, PartialEq, Clone, Serialize, Deserialize)]
#[serde(rename_all = "UPPERCASE")]
pub enum FileType {
    TestFile,
    PrimaryDescriptor,
    SecondaryDescriptor,
    Containerfile,
    Other,
}

impl FileType {
    pub fn new_from_file_type(file_type: &config::FileType) -> Self {
        match file_type {
            config::FileType::Primary => FileType::PrimaryDescriptor,
            config::FileType::Secondary => FileType::SecondaryDescriptor,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Serialize, Deserialize)]
pub struct ToolFile {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub path: Option<Url>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub file_type: Option<FileType>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub checksum: Option<Checksum>,
}

#[derive(Debug, PartialEq, Clone, Serialize, Deserialize)]
pub struct ToolClass {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
}

impl Default for ToolClass {
    fn default() -> Self {
        ToolClass {
            id: Some("workflow".to_string()),
            name: Some("Workflow".to_string()),
            description: Some("A computational workflow".to_string()),
        }
    }
}

#[derive(Debug, PartialEq, Clone, Serialize, Deserialize)]
pub struct Tool {
    pub url: Url,
    pub id: Uuid,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub aliases: Option<Vec<String>>,
    pub organization: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    pub tool_class: ToolClass,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<Url>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub meta_version: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub has_checker: Option<bool>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub checker_url: Option<Url>,
    pub versions: Vec<ToolVersion>,
}

impl Tool {
    pub fn new(
        config: &config::Config,
        owner: impl AsRef<str>,
        name: impl AsRef<str>,
    ) -> Result<Self> {
        Ok(Self {
            url: Url::parse(&format!(
                "https://{}.github.io/{}/tools/{}",
                owner.as_ref(),
                name.as_ref(),
                config.id.to_string(),
            ))?,
            id: config.id,
            aliases: None,
            organization: config.authors[0].github_account.clone(), // already validated
            name: Some(config.workflow.name.clone()),
            tool_class: ToolClass::default(),
            description: Some(config.workflow.readme.clone()),
            meta_version: None,
            has_checker: None,
            checker_url: None,
            versions: vec![],
        })
    }

    /// Scans for versions field and updates them based on the version of the config.
    /// If the same version already exists, it will be overwritten.
    pub fn add_new_tool_version(
        &mut self,
        config: &config::Config,
        owner: impl AsRef<str>,
        name: impl AsRef<str>,
    ) -> Result<()> {
        let mut versions = self
            .versions
            .clone()
            .into_iter()
            .filter(|v| v.version() != config.version)
            .collect::<Vec<ToolVersion>>();
        versions.push(ToolVersion::new(&config, &owner, &name)?);
        self.versions = versions;
        Ok(())
    }
}

#[derive(Debug, PartialEq, Clone, Serialize, Deserialize)]
pub struct ToolVersion {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub author: Option<Vec<String>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,
    pub url: Url,
    pub id: Uuid,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub is_production: Option<bool>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub images: Option<Vec<ImageData>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub descriptor_type: Option<Vec<DescriptorType>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub containerfile: Option<bool>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub meta_version: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub verified: Option<bool>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub verified_source: Option<Vec<String>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub signed: Option<bool>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub included_apps: Option<Vec<String>>,
}

impl ToolVersion {
    pub fn new(
        config: &config::Config,
        owner: impl AsRef<str>,
        name: impl AsRef<str>,
    ) -> Result<Self> {
        Ok(Self {
            author: Some(
                config
                    .authors
                    .iter()
                    .map(|a| a.github_account.clone())
                    .collect::<Vec<String>>(),
            ),
            name: Some(config.workflow.name.clone()),
            url: Url::parse(&format!(
                "https://{}.github.io/{}/tools/{}/versions/{}",
                owner.as_ref(),
                name.as_ref(),
                config.id.to_string(),
                &config.version
            ))?,
            id: config.id,
            is_production: None,
            images: None,
            descriptor_type: Some(vec![DescriptorType::new(
                &config
                    .workflow
                    .language
                    .r#type
                    .clone()
                    .ok_or(anyhow!("No language type"))?,
            )]),
            containerfile: None,
            meta_version: None,
            verified: None,
            verified_source: None,
            signed: None,
            included_apps: None,
        })
    }

    pub fn version(&self) -> String {
        let path_segments = self.url.path_segments().unwrap();
        let version = path_segments.last().unwrap().to_string();
        version
    }
}

#[derive(Debug, PartialEq, Clone, Serialize, Deserialize)]
pub struct ImageData {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub registry_host: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub image_name: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub size: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub updated: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub checksum: Option<Checksum>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub image_type: Option<ImageType>,
}

#[derive(Debug, PartialEq, Clone, Serialize, Deserialize)]
pub enum ImageType {
    Docker,
    Singularity,
    Conda,
}

#[derive(Debug, PartialEq, Clone, Serialize, Deserialize)]
#[serde(rename_all = "UPPERCASE")]
pub enum DescriptorType {
    Cwl,
    Wdl,
    Nfl,
    Smk,
    Galaxy,
}

impl DescriptorType {
    fn new(wf_type: &config::LanguageType) -> Self {
        match wf_type {
            config::LanguageType::Cwl => DescriptorType::Cwl,
            config::LanguageType::Wdl => DescriptorType::Wdl,
            config::LanguageType::Nfl => DescriptorType::Nfl,
            config::LanguageType::Smk => DescriptorType::Smk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Serialize, Deserialize)]
#[serde(rename_all = "UPPERCASE")]
enum DescriptorTypeWithPlain {
    Cwl,
    Wdl,
    Nfl,
    Smk,
    Galaxy,
    PlainCwl,
    PlainWdl,
    PlainNfl,
    PlainSmk,
    PlainGalaxy,
}

/// One of url or content is required.
#[derive(Debug, PartialEq, Clone, Serialize, Deserialize)]
pub struct FileWrapper {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub content: Option<String>, // The content of the file itself. One of url or content is required.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub checksum: Option<Vec<Checksum>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub url: Option<Url>,
}

#[cfg(test)]
#[cfg(not(tarpaulin_include))]
mod tests {
    use super::*;

    use serde_yaml;
    use std::fs;
    use std::io::BufReader;

    #[test]
    fn test_new_or_update_service_info_with_none() -> Result<()> {
        let reader = BufReader::new(fs::File::open("./tests/test_config_CWL_validated.yml")?);
        let config: config::Config = serde_yaml::from_reader(reader)?;
        ServiceInfo::new_or_update(None, &config, "test_owner", "test_name")?;
        Ok(())
    }

    #[test]
    fn test_new_or_update_tool_version_with_none() -> Result<()> {
        let reader = BufReader::new(fs::File::open("./tests/test_config_CWL_validated.yml")?);
        let config: config::Config = serde_yaml::from_reader(reader)?;
        ToolVersion::new(&config, "test_owner", "test_name")?;
        Ok(())
    }
}
