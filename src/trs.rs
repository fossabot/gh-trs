use crate::config;

use anyhow::{anyhow, Result};
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use serde_with::skip_serializing_none;
use url::Url;
use uuid::Uuid;

/// https://raw.githubusercontent.com/ga4gh-discovery/ga4gh-service-info/v1.0.0/service-info.yaml#/paths/~1service-info
#[skip_serializing_none]
#[derive(Debug, PartialEq, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct ServiceInfo {
    pub id: String,
    pub name: String,
    pub r#type: ServiceType,
    pub description: Option<String>,
    pub organization: Organization,
    pub contact_url: Option<Url>,
    pub documentation_url: Option<Url>,
    #[serde(serialize_with = "serialize_date_time")]
    pub created_at: Option<DateTime<Utc>>,
    #[serde(serialize_with = "serialize_date_time")]
    pub updated_at: Option<DateTime<Utc>>,
    pub environment: Option<String>,
    pub version: String,
}

fn serialize_date_time<S>(dt: &Option<DateTime<Utc>>, serializer: S) -> Result<S::Ok, S::Error>
where
    S: serde::Serializer,
{
    match dt {
        Some(dt) => serializer.serialize_str(&format!("{}", dt.format("%Y-%m-%dT%H:%M:%SZ"))),
        None => serializer.serialize_none(),
    }
}

#[derive(Debug, PartialEq, Clone, Serialize, Deserialize)]
pub struct ServiceType {
    pub group: String,
    pub artifact: String,
    pub version: String,
}

impl Default for ServiceType {
    fn default() -> Self {
        Self {
            group: "gh-trs".to_string(),
            artifact: "gh-trs".to_string(),
            version: "2.0.1".to_string(),
        }
    }
}

#[derive(Debug, PartialEq, Clone, Serialize, Deserialize)]
pub struct Organization {
    pub name: String,
    pub url: Url,
}

impl ServiceInfo {
    fn new(config: &config::Config, owner: impl AsRef<str>, name: impl AsRef<str>) -> Result<Self> {
        let created_at = Utc::now();
        Ok(Self {
            id: format!("io.github.{}.{}", owner.as_ref(), name.as_ref()),
            name: format!("gh-trs {}/{}", owner.as_ref(), name.as_ref()),
            r#type: ServiceType::default(),
            description: Some(
                "The GA4GH TRS API generated by gh-trs (https://github.com/suecharo/gh-trs)"
                    .to_string(),
            ),
            organization: Organization {
                name: config.authors[0].github_account.clone(), // already validated
                url: Url::parse(&format!(
                    "https://github.com/{}",
                    config.authors[0].github_account // already validated
                ))?,
            },
            contact_url: None::<Url>,
            documentation_url: None::<Url>,
            created_at: Some(created_at),
            updated_at: Some(created_at.clone()),
            environment: None::<String>,
            version: created_at.format("%Y%m%d%H%M%S").to_string(),
        })
    }

    /// Basically, prev has priority in all fields.
    /// This is only for service-info, because there may be cases where to modify service-info by hand.
    pub fn new_or_update(
        prev: Option<Self>,
        config: &config::Config,
        owner: impl AsRef<str>,
        name: impl AsRef<str>,
    ) -> Result<Self> {
        let mut new = Self::new(config, owner, name)?;
        if let Some(prev) = prev {
            new.id = prev.id;
            new.name = prev.name;
            new.r#type = prev.r#type;
            new.description = prev.description;
            new.organization = prev.organization;
            new.contact_url = prev.contact_url;
            new.documentation_url = prev.documentation_url;
            new.created_at = prev.created_at;
            new.environment = prev.environment;
        }
        Ok(new)
    }
}

// --- GA4GH TRS API v2.0.1 type definition ---
// https://editor.swagger.io/?url=https://raw.githubusercontent.com/ga4gh/tool-registry-schemas/develop/openapi/openapi.yaml

#[derive(Debug, PartialEq, Clone, Serialize, Deserialize)]
pub struct Checksum {
    pub checksum: String,
    pub r#type: String,
}

#[derive(Debug, PartialEq, Clone, Serialize, Deserialize)]
pub enum FileType {
    #[serde(rename = "TEST_FILE")]
    TestFile,
    #[serde(rename = "PRIMARY_DESCRIPTOR")]
    PrimaryDescriptor,
    #[serde(rename = "SECONDARY_DESCRIPTOR")]
    SecondaryDescriptor,
    #[serde(rename = "CONTAINERFILE")]
    Containerfile,
    #[serde(rename = "OTHER")]
    Other,
}

impl FileType {
    pub fn new_from_file_type(file_type: &config::FileType) -> Self {
        match file_type {
            config::FileType::Primary => FileType::PrimaryDescriptor,
            config::FileType::Secondary => FileType::SecondaryDescriptor,
        }
    }
}

#[skip_serializing_none]
#[derive(Debug, PartialEq, Clone, Serialize, Deserialize)]
pub struct ToolFile {
    pub path: Option<Url>,
    pub file_type: Option<FileType>,
    pub checksum: Option<Checksum>,
}

#[skip_serializing_none]
#[derive(Debug, PartialEq, Clone, Serialize, Deserialize)]
pub struct ToolClass {
    pub id: Option<String>,
    pub name: Option<String>,
    pub description: Option<String>,
}

impl Default for ToolClass {
    fn default() -> Self {
        ToolClass {
            id: Some("workflow".to_string()),
            name: Some("Workflow".to_string()),
            description: Some("A computational workflow".to_string()),
        }
    }
}

#[skip_serializing_none]
#[derive(Debug, PartialEq, Clone, Serialize, Deserialize)]
pub struct Tool {
    pub url: Url,
    pub id: Uuid,
    pub aliases: Option<Vec<String>>,
    pub organization: String,
    pub name: Option<String>,
    pub tool_class: ToolClass,
    pub description: Option<Url>,
    pub meta_version: Option<String>,
    pub has_checker: Option<bool>,
    pub checker_url: Option<Url>,
    pub versions: Vec<ToolVersion>,
}

impl Tool {
    pub fn new(
        config: &config::Config,
        owner: impl AsRef<str>,
        name: impl AsRef<str>,
    ) -> Result<Self> {
        Ok(Self {
            url: Url::parse(&format!(
                "https://{}.github.io/{}/tools/{}",
                owner.as_ref(),
                name.as_ref(),
                config.id.to_string(),
            ))?,
            id: config.id,
            aliases: None,
            organization: config.authors[0].github_account.clone(), // already validated
            name: Some(config.workflow.name.clone()),
            tool_class: ToolClass::default(),
            description: Some(config.workflow.readme.clone()),
            meta_version: None,
            has_checker: None,
            checker_url: None,
            versions: vec![],
        })
    }

    /// Scans for versions field and updates them based on the version of the config.
    /// If the same version already exists, it will be overwritten.
    pub fn add_new_tool_version(
        &mut self,
        config: &config::Config,
        owner: impl AsRef<str>,
        name: impl AsRef<str>,
    ) -> Result<()> {
        let mut versions = self
            .versions
            .clone()
            .into_iter()
            .filter(|v| v.version() != config.version)
            .collect::<Vec<ToolVersion>>();
        versions.push(ToolVersion::new(&config, &owner, &name)?);
        self.versions = versions;
        Ok(())
    }
}

#[skip_serializing_none]
#[derive(Debug, PartialEq, Clone, Serialize, Deserialize)]
pub struct ToolVersion {
    pub author: Option<Vec<String>>,
    pub name: Option<String>,
    pub url: Url,
    pub id: Uuid,
    pub is_production: Option<bool>,
    pub images: Option<Vec<ImageData>>,
    pub descriptor_type: Option<Vec<DescriptorType>>,
    pub containerfile: Option<bool>,
    pub meta_version: Option<String>,
    pub verified: Option<bool>,
    pub verified_source: Option<Vec<String>>,
    pub signed: Option<bool>,
    pub included_apps: Option<Vec<String>>,
}

impl ToolVersion {
    pub fn new(
        config: &config::Config,
        owner: impl AsRef<str>,
        name: impl AsRef<str>,
    ) -> Result<Self> {
        Ok(Self {
            author: Some(
                config
                    .authors
                    .iter()
                    .map(|a| a.github_account.clone())
                    .collect::<Vec<String>>(),
            ),
            name: Some(config.workflow.name.clone()),
            url: Url::parse(&format!(
                "https://{}.github.io/{}/tools/{}/versions/{}",
                owner.as_ref(),
                name.as_ref(),
                config.id.to_string(),
                &config.version
            ))?,
            id: config.id,
            is_production: None,
            images: None,
            descriptor_type: Some(vec![DescriptorType::new(
                &config
                    .workflow
                    .language
                    .r#type
                    .clone()
                    .ok_or(anyhow!("No language type"))?,
            )]),
            containerfile: None,
            meta_version: None,
            verified: None,
            verified_source: None,
            signed: None,
            included_apps: None,
        })
    }

    pub fn version(&self) -> String {
        let path_segments = self.url.path_segments().unwrap();
        let version = path_segments.last().unwrap().to_string();
        version
    }
}

#[skip_serializing_none]
#[derive(Debug, PartialEq, Clone, Serialize, Deserialize)]
pub struct ImageData {
    pub registry_host: Option<String>,
    pub image_name: Option<String>,
    pub size: Option<String>,
    pub updated: Option<String>,
    pub checksum: Option<Checksum>,
    pub image_type: Option<ImageType>,
}

#[derive(Debug, PartialEq, Clone, Serialize, Deserialize)]
pub enum ImageType {
    Docker,
    Singularity,
    Conda,
}

#[derive(Debug, PartialEq, Clone, Serialize, Deserialize)]
#[serde(rename_all = "UPPERCASE")]
pub enum DescriptorType {
    Cwl,
    Wdl,
    Nfl,
    Smk,
    Galaxy,
}

impl DescriptorType {
    fn new(wf_type: &config::LanguageType) -> Self {
        match wf_type {
            config::LanguageType::Cwl => DescriptorType::Cwl,
            config::LanguageType::Wdl => DescriptorType::Wdl,
            config::LanguageType::Nfl => DescriptorType::Nfl,
            config::LanguageType::Smk => DescriptorType::Smk,
        }
    }
}

#[derive(Debug, PartialEq, Clone, Serialize, Deserialize)]
#[serde(rename_all = "UPPERCASE")]
enum DescriptorTypeWithPlain {
    Cwl,
    Wdl,
    Nfl,
    Smk,
    Galaxy,
    PlainCwl,
    PlainWdl,
    PlainNfl,
    PlainSmk,
    PlainGalaxy,
}

/// One of url or content is required.
#[skip_serializing_none]
#[derive(Debug, PartialEq, Clone, Serialize, Deserialize)]
pub struct FileWrapper {
    pub content: Option<String>, // The content of the file itself. One of url or content is required.
    pub checksum: Option<Vec<Checksum>>,
    pub url: Option<Url>,
}

#[cfg(test)]
#[cfg(not(tarpaulin_include))]
mod tests {
    use super::*;

    use serde_json;
    use serde_yaml;
    use std::fs;
    use std::io::BufReader;

    #[test]
    fn test_new_or_update_service_info() -> Result<()> {
        let reader = BufReader::new(fs::File::open("./tests/test_config_CWL_validated.yml")?);
        let config: config::Config = serde_yaml::from_reader(reader)?;
        let service_info = ServiceInfo::new_or_update(None, &config, "test_owner", "test_name")?;

        let expect = serde_json::from_str::<ServiceInfo>(
            r#"
{
  "id": "io.github.test_owner.test_name",
  "name": "gh-trs test_owner/test_name",
  "type": {
    "group": "gh-trs",
    "artifact": "gh-trs",
    "version": "2.0.1"
  },
  "description": "The GA4GH TRS API generated by gh-trs (https://github.com/suecharo/gh-trs)",
  "organization": {
    "name": "suecharo",
    "url": "https://github.com/suecharo"
  },
  "createdAt": "2022-02-07T14:05:57Z",
  "updatedAt": "2022-02-07T14:05:57Z",
  "version": "20220207140557"
}"#,
        )?;
        assert_eq!(service_info.id, expect.id);
        assert_eq!(service_info.name, expect.name);
        assert_eq!(service_info.r#type, expect.r#type);
        assert_eq!(service_info.description, expect.description);
        assert_eq!(service_info.organization, expect.organization);
        Ok(())
    }

    #[test]
    fn test_file_type_new_from_file_type() -> Result<()> {
        let file_type = FileType::new_from_file_type(&config::FileType::Primary);
        assert_eq!(file_type, FileType::PrimaryDescriptor);
        let file_type = FileType::new_from_file_type(&config::FileType::Secondary);
        assert_eq!(file_type, FileType::SecondaryDescriptor);
        Ok(())
    }

    #[test]
    fn test_default_tool_class() -> Result<()> {
        let tool_class = ToolClass::default();
        assert_eq!(tool_class.id, Some("workflow".to_string()));
        assert_eq!(tool_class.name, Some("Workflow".to_string()));
        assert_eq!(
            tool_class.description,
            Some("A computational workflow".to_string())
        );
        Ok(())
    }

    #[test]
    fn test_tool_new() -> Result<()> {
        let reader = BufReader::new(fs::File::open("./tests/test_config_CWL_validated.yml")?);
        let config: config::Config = serde_yaml::from_reader(reader)?;
        let tool = Tool::new(&config, "test_owner", "test_name")?;

        let expect = serde_json::from_str::<Tool>(
            r#"
{
  "url": "https://test_owner.github.io/test_name/tools/5ca05f9a-d98d-42ee-8057-02abbbb6011f",
  "id": "5ca05f9a-d98d-42ee-8057-02abbbb6011f",
  "organization": "suecharo",
  "name": "trimming_and_qc",
  "tool_class": {
    "id": "workflow",
    "name": "Workflow",
    "description": "A computational workflow"
  },
  "description": "https://raw.githubusercontent.com/suecharo/gh-trs/b02f189daddcbc2c0a2c0091300f2b90cca49c49/README.md",
  "versions": []
}"#,
        )?;
        assert_eq!(tool, expect);
        Ok(())
    }

    #[test]
    fn test_tool_add_new_tool_version() -> Result<()> {
        let reader = BufReader::new(fs::File::open("./tests/test_config_CWL_validated.yml")?);
        let config: config::Config = serde_yaml::from_reader(reader)?;
        let mut tool = Tool::new(&config, "test_owner", "test_name")?;
        tool.add_new_tool_version(&config, "test_owner", "test_name")?;
        assert_eq!(tool.versions.len(), 1);
        tool.add_new_tool_version(&config, "test_owner", "test_name")?;
        assert_eq!(tool.versions.len(), 1);

        let expect = serde_json::from_str::<Tool>(
            r#"
{
  "url": "https://test_owner.github.io/test_name/tools/5ca05f9a-d98d-42ee-8057-02abbbb6011f",
  "id": "5ca05f9a-d98d-42ee-8057-02abbbb6011f",
  "organization": "suecharo",
  "name": "trimming_and_qc",
  "tool_class": {
    "id": "workflow",
    "name": "Workflow",
    "description": "A computational workflow"
  },
  "description": "https://raw.githubusercontent.com/suecharo/gh-trs/b02f189daddcbc2c0a2c0091300f2b90cca49c49/README.md",
  "versions": [
    {
      "author": [
        "suecharo"
      ],
      "name": "trimming_and_qc",
      "url": "https://test_owner.github.io/test_name/tools/5ca05f9a-d98d-42ee-8057-02abbbb6011f/versions/1.0.0",
      "id": "5ca05f9a-d98d-42ee-8057-02abbbb6011f",
      "descriptor_type": [
        "CWL"
      ]
    }
  ]
}"#,
        )?;
        assert_eq!(tool, expect);
        Ok(())
    }

    #[test]
    fn test_tool_version_new() -> Result<()> {
        let reader = BufReader::new(fs::File::open("./tests/test_config_CWL_validated.yml")?);
        let config: config::Config = serde_yaml::from_reader(reader)?;
        let tool_version = ToolVersion::new(&config, "test_owner", "test_name")?;

        let expect = serde_json::from_str::<ToolVersion>(
            r#"
{
  "author": [
    "suecharo"
  ],
  "name": "trimming_and_qc",
  "url": "https://test_owner.github.io/test_name/tools/5ca05f9a-d98d-42ee-8057-02abbbb6011f/versions/1.0.0",
  "id": "5ca05f9a-d98d-42ee-8057-02abbbb6011f",
  "descriptor_type": [
    "CWL"
  ]
}"#,
        )?;
        assert_eq!(tool_version, expect);
        Ok(())
    }

    #[test]
    fn test_tool_version_version() -> Result<()> {
        let reader = BufReader::new(fs::File::open("./tests/test_config_CWL_validated.yml")?);
        let config: config::Config = serde_yaml::from_reader(reader)?;
        let tool_version = ToolVersion::new(&config, "test_owner", "test_name")?;
        let version = tool_version.version();
        assert_eq!(version, "1.0.0");
        Ok(())
    }
}
